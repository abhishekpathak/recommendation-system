# -*- coding: utf-8 -*-
import json
import logging
from abc import ABC, abstractmethod
from io import TextIOWrapper

from core import config, utils
from core.exceptions import WarehouseException

logger = logging.getLogger(__name__)


class Warehouse(ABC):
    """ Documents the APIs that the data warehouse should expose.

    The warehouse will typically be an external system, itself composed of
    various sub-systems. For example, it can be a Hadoop-based system
    consisting of HDFSto persist files and tools like Hive, Spark etc. to
    manage the data in these files. In our case, we are prototyping such a
    system and fleshing out the API that such a system should expose to
    support our application.

    """

    @abstractmethod
    def update_ratings(self, new_ratings) -> None:
        """ adds new ratings data to its global ratings data.

        Args:
            new_ratings: new ratings data, type will be warehouse-specific.

        """
        pass

    @abstractmethod
    def update_users(self, users) -> None:
        """ adds new users' data to its global users data.

        Args:
            users: new users data, type will be warehouse-specific.

        """
        pass

    @abstractmethod
    def update_recommendations(self, user_id: int,
                               recommendations: list) -> None:
        pass

    @staticmethod
    @abstractmethod
    def write_row(handle: object, data: dict) -> None:
        """ A generic method that can be used by any handle-aware caller to add
        a new record to the warehouse.

        The implementation can vary among different warehouses. File-based
        warehouses might write to a file, table-based warehouses might insert
        to a table etc.

        Args:
            handle: the handle to the persisted data. Can be a file, table etc.
            data: A dict containing the new record to be added.
        """
        pass


class FileWarehouse(Warehouse):
    """ A simple prototype warehouse. Stores data in JSON-based files.

    Suffers from a lot of drawbacks due to its nature - directly manipulating
    files. However, it implements the warehouse contract, and will suffice for
    our system.

    Attributes:
        partition: the warehouse "partition" that serves as an id for the
        data that we are interested in. All the files related to one source are
        dumped under the same partition.

        root_path: the warehouse path locator/directory corresponding to one
        type of data.

        ratings_file: a warehouse file containing the ratings data in a
        standard format.

        training_file: a warehouse file containing the training data in a
        standard format. A subset of the ratings data.

        test_file: a warehouse file containing the test data in a standard
        format. A subset of the ratings data.

        validation_file: a warehouse file containing the validation data in a
        standard format. A subset of the ratings data.

        products_file: a warehouse file containing the product details in a
        standard format.

        recommendations_file: a warehouse file that contains the recommendations
        generated by the engine.

        users_file: a warehouse file containing the details of all the active
        users of the system.

    """
    def __init__(self, partition: str):
        self.partition = partition
        self.root_path = '{}/{}'.format(config.WAREHOUSE_DATA_DIR,
                                        self.partition)
        self.ratings_file = '{}/ratings'.format(self.root_path)
        self.training_file = '{}/training'.format(self.root_path)
        self.test_file = '{}/test'.format(self.root_path)
        self.validation_file = '{}/validation'.format(self.root_path)
        self.products_file = '{}/products'.format(self.root_path, )
        self.recommendations_file = '{}/recommendations'.format(self.root_path)
        self.users_file = '{}/users'.format(self.root_path)

    def cleanup(self) -> None:
        """ Sanitizes and bootstraps a warehouse partition.

        Removes any any residual data in a warehouse (partition) and makes it
        available for use. This is a one-time task, typically run after a fresh
        warehouse (partition) is created and before it starts storing data.

        """
        utils.delete_directory(self.root_path)

        utils.create_directory(self.root_path)

        for file in (
                self.ratings_file,
                self.training_file,
                self.test_file,
                self.validation_file,
                self.products_file,
                self.recommendations_file,
                self.users_file):
            utils.touch_file(file)

    def delete(self) -> None:
        """ Removes all data from the warehouse partition """
        utils.delete_directory(self.root_path)

    def update_ratings(self, new_ratings: list) -> None:
        """ Implements `Warehouse.update_ratings`. Assumes new ratings as
        incremental updates, and adds them to the ratings file.

        Args:
            new_ratings: a list of ratings, where each rating is a dict with the
            keys `user_id`, `product_id` and `rating`.

        """
        # TODO check for duplicate entries in ratings file and deduplicate.
        try:
            with open(self.ratings_file, 'a') as ratings_file:
                for rating in new_ratings:
                    self.write_row(ratings_file, rating)
        except IOError as e:
            message = "Unable to update ratings. Error reported:{}".format(e)
            logger.error(message)
            raise WarehouseException(message) from e

    def update_users(self, users: list) -> None:
        """ Implements `Warehouse.update_users`. Assumes a global list of users
        to be provided each time, and swaps its current data for the new data.

        Args:
            users: a list of users, where each user is a dict with a single
            key `user_id`.

        """
        try:
            with open(self.users_file, 'w') as users_file:
                for user in users:
                    self.write_row(users_file, user)
        except IOError as e:
            message = "Unable to update users. Error reported:{}".format(e)
            logger.error(message)
            raise WarehouseException(message) from e

    def update_recommendations(self, user_id: int,
                               recommendations: list) -> None:
        """ Implements `Warehouse.update_recommendations.` Stores the
        recommendations for the given user id. As of now adds a new
        recommendation naively.

        Args:
            user_id: the id of the user for which recommendations are generated.

            recommendations: A list of recommendations sorted from best to
            worst. Each recommendation is just a product id.

        """
        recommendation_dict = {
            config.USER_COL: user_id,
            'recommendations': recommendations
        }

        # TODO Should ideally upsert (update if exists, add otherwise)
        try:
            with open(self.recommendations_file, 'a') as recommendations_file:
                self.write_row(recommendations_file, recommendation_dict)
        except IOError as e:
            message = "Unable to update recommendations. Error reported:{}".format(e)
            logger.error(message)
            raise WarehouseException(message)

    @staticmethod
    def write_row(handle: TextIOWrapper, data: dict) -> None:
        """ A generic method that can be used by any file-aware caller.
        Implements `Warehouse.write_row` for a json files based system.

        Args:
            handle: the handle to the file to be written to.
            data: A dict containing the data to be added. Will be added as a
            new json line.
        """
        json.dump(data, handle)
        handle.write('\n')
